/* %Z% %W% %I% %E% %U% */
/*
 * <copyright
 * notice="lm-source-program"
 * pids="5755-P60"
 * years="2013,2014"
 * crc="3568777996" >
 * Licensed Materials - Property of IBM
 *
 * 5755-P60
 *
 * (C) Copyright IBM Corp. 2014
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 * </copyright>
 */
/* jslint node: true */
/* jshint -W083,-W097 */
'use strict';


/** NODE_ENV = 'unittest' loads a stub instead of the Proton library */
process.env.NODE_ENV = 'unittest';
var testCase = require('nodeunit').testCase;
var mqlight = require('../mqlight');
var fs = require('fs');


/**
 * Tests the golden path through using a client.
 * @param {object} test - test case.
 */
module.exports.test_golden_path = function(test) {
  test.expect(6);
  var opts = {service: 'amqp://myhost.1234:5672', id: 'test'};
  var client = mqlight.createClient(opts, function(err) {
    if (err) {
      console.log('error on start: ' + err);
      test.ok(false);
      test.done();
    }
  });
  test.ok(typeof client === 'object', 'CreateClient returns an object');
  test.equal('test', client.id, 'Client id equals what was set');
  test.equal('starting', client.state,
             'Initial state is starting');
  test.equal(undefined, client.service,
             'Service is undefined before a client attains started state');


  client.on('started', function() {

    test.equal('started', client.state,
               'Client state equals started once the started event is ' +
               'emitted');
    test.equal(opts.service, client.service,
               'Supplied service matches result of client.service property ' +
               'after start');
    client.stop();
    test.done();
  });
};


/**
 * Test that a service name must be a string value.
 * @param {object} test - test case.
 */
module.exports.test_service_not_a_string = function(test) {
  test.throws(function() {
    mqlight.createClient({service: 123});
  }, function(err) {
    if ((err instanceof TypeError) &&
        /service must be a string or array type/.test(err)) {
      return true;
    }
  }, 'Service parameter as non string/array test');
  test.done();
};


/**
 * Test that passing no values to createClient is not valid.
 * @param {object} test - test case.
 */
module.exports.test_createClient_must_have_a_value = function(test) {
  test.throws(function() {
    mqlight.createClient();
  }, function(err) {
    if ((err instanceof TypeError) &&
        /options object missing/.test(err)) {
      return true;
    }
  }, 'somr properties myst be passed to createClient(...)');
  test.done();
};


/**
 * Test that omitting the 'service' property from createClient causes an error.
 * @param {object} test - test case.
 */
module.exports.test_createClient_must_have_service_value = function(test) {
  test.throws(function() {
    mqlight.createClient({id: 'abc'});
  }, function(err) {
    if ((err instanceof Error) && /service is undefined/.test(err)) {
      return true;
    }
  }, 'service property must be specified to createClient(...)');

  test.done();
};


/**
 * Test that, providing the thing passed into createClient(...) has a 'service'
 * property - then it's happy...
 * @param {object} test - test case.
 */
module.exports.test_createClient_ignores_unknown_properties = function(test) {
  var oddOpts = function() {};  // for added craziness: not an object...
  oddOpts.service = 'amqp://localhost';
  oddOpts.fruit = 'avocado';
  oddOpts.size = 3;
  mqlight.createClient(oddOpts, function(err, client) {
    client.stop(function() {
      test.done();
    });
  });
};


/**
 * Test a range of types / values for client IDs.
 * @param {object} test - test case.
 */
module.exports.test_id_types_values = function(test) {
  var testData = [{data: 1234, valid: true},
                  {data: null, valid: true},
                  {data: true, valid: true},
                  {data: 'abc123', valid: true},
                  {data: ':1234', valid: false},
                  {data: '1234:', valid: false},
                  {data: '12:34', valid: false},
                  {data: '%._', valid: true}];
  
  var runTest = function(i) {
    try {
      var opts = {service: 'amqp://localhost', id: testData[i].data};
      mqlight.createClient(opts, function(err, client) {
        test.ok(!err);
        client.stop((i == testData.length-1) ? test.done : runTest(i+1));
      });
      test.ok(testData[i].valid, "Expected '" + testData[i].data +
          "' to be invalid");
    } catch (_) {
      if (testData[i].valid) {
        console.log(testData[i]);
        throw _;
      }
      if (i < (testData.length-1)) {
        runTest(i+1);
      } else {
        test.done();
      }
    }
  };
  
  runTest(0);
};


/**
 * Test that if the 'id' property is omitted then a client id will be
 * generated.
 * @param {object} test - test case.
 */
module.exports.test_id_autogenerated = function(test) {
  var client = 
      mqlight.createClient({service: 'amqp://localhost:5672'}, function() {
                 client.stop(test.done);
               });
      
  test.ok(/AUTO_[a-z0-9]{7}/.test(client.id), 'weird generated id: ' +
          client.id);
};


/**
 * Test a range of user and password types / values.
 * @param {object} test - test case.
 */
module.exports.test_user_password_types_values = function(test) {
  var testData = [{user: 'abc', password: undefined, valid: false},
                  {user: undefined, password: 'abc', valid: false},
                  {user: 'abc', password: '123', valid: true},
                  {user: 1234, password: 'abc', valid: true},
                  {user: 'abc', password: 1234, valid: true},
                  {user: '!"$%^&*()-_=+[{]};:\'@#~|<,>.?/',
          password: '!"$%^&*()-_=+[{]};:\'@#~|<,>.?/',
          valid: true}];
  
  var runTests = function(i) {
    try {
      var opts = {
        service: 'amqp://localhost:5672',
        user: testData[i].user,
        password: testData[i].password
      };
      
      mqlight.createClient(opts, function(err, client) {
        test.ok(!err);
        client.stop((i < testData.length - 1) ? runTests(i+1) : test.done)
      });
      test.ok(testData[i].valid, "Expected '" + testData[i].user + '/' +
              testData[i].password + "' to be invalid");
    } catch (_) {
      if (testData[i].valid) {
        console.log(i);
        throw _;
      } else if (i < testData.length - 1) {
        runTests(i+1);
      } else {
        test.done();
      }
    }
  };
  
  runTests(0);
};


/**
 * Test that a clear-text password isn't trivially recoverable from the client
 * object.
 * @param {object} test - test case.
 */
module.exports.test_password_hidden = function(test) {
  var opts = {
    service: 'amqp://localhost:5672',
    user: 'bob',
    password: 's3cret'
  };
  var client = mqlight.createClient(opts);
  var inspectedClient = require('util').inspect(client);
  test.ok(!/s3cret/.test(inspectedClient), inspectedClient);
  test.done();
};


/**
 * Test a range of invalid URIs are rejected.
 * @param {object} test - test case.
 */
module.exports.test_invalid_URIs = function(test) {
  var invalidUris = ['amqp://amqp://Wrong',
                     'amqp://localhost:34:34',
                     'amqp://test:-34',
                     'amqp://here:34/path',
                     'amqp://rupert@NotThere',
                     'amqp://:34',
                     "ce n'est pas une uri"];
  test.expect(invalidUris.length);
  for (var i = 0; i < invalidUris.length; i++) {
    test.throws(function() {
      var opts = {
        service: invalidUris[i],
        id: 'testid'
      };
      mqlight.createClient(opts);
    }, function(err) {
      if (err instanceof Error) {
        return true;
      }
    }, 'invalid URI test (' + i + '): ' + invalidUris[i]);
  }
  test.done();
};


/**
 * Test that the value returned by client.service is a lower cased URL
 * which always has a port number.
 * @param {object} test - test case.
 */
module.exports.test_valid_URIs = function(test) {
  var testData = [{uri: 'amqp://host', expected: 'amqp://host:5672'},
                  {uri: 'amqps://host', expected: 'amqps://host:5671'},
                  {uri: 'AmQp://HoSt', expected: 'amqp://host:5672'},
                  {uri: 'aMqPs://hOsT', expected: 'amqps://host:5671'},
                  {uri: 'amqp://host:1234', expected: 'amqp://host:1234'},
                  {uri: 'amqps://host:4321', expected: 'amqps://host:4321'},
                  {uri: 'aMqP://HoSt:1234', expected: 'amqp://host:1234'},
                  {uri: 'AmQpS://hOsT:4321', expected: 'amqps://host:4321'},
                  {uri: 'amqp://user:pass@host:1234',
                    expected: 'amqp://host:1234'}];
  var count = 0;
  var clientTest = function(uri, expected) {
    var client = mqlight.createClient({service: uri});
    client.start(function(err) {
      test.ok(!err);
      test.equals(expected, client.service);
      client.stop();
      ++count;
      if (count == testData.length) {
        test.done();
      } else {
        clientTest(testData[count].uri, testData[count].expected);
      }
    });
  };

  clientTest(testData[count].uri, testData[count].expected);
};


/**
 * Test that if too many arguments are supplied to createClient - then they are
 * ignored.
 * @param {object} test the unittest interface
 */
module.exports.test_createClient_too_many_arguments = function(test) {
  mqlight.createClient({service: 'amqp://host'}, function(){}, 'wallflower');
  test.done();
};


/**
 * Test that bad ssl options cause createClient to fail
 * @param {object} test - test case.
 */
module.exports.test_bad_ssl_options = function(test) {
  var testData = [{sslTrustCertificate: 1, sslVerifyName: true},
                  {sslTrustCertificate: {a:1}, sslVerifyName: true},
                  {sslTrustCertificate: true, sslVerifyName: true},
                  {sslTrustCertificate:'ValidCertificate', sslVerifyName:'a'},
                  {sslTrustCertificate:'ValidCertificate', sslVerifyName: 1},
                  {sslTrustCertificate:'ValidCertificate',
                    sslVerifyName:{a:1}},
                  {sslTrustCertificate:'MissingCertificate',
                    sslVerifyName:true},
                  {sslTrustCertificate:'dirCertificate',
                    sslVerifyName:true}];
  fs.mkdirSync('dirCertificate');
  test.expect(testData.length);
  for (var i = 0; i < testData.length; i++) {
    test.throws(function() {
      var opts = {
        service: 'amqp://host',
        sslTrustCertificate : testData[i].sslTrustCertificate,
        sslVerifyName : testData[i].sslVerifyName,
        id: 'testid'
      };
      mqlight.createClient(opts);
    }, function(err) {
      if (err instanceof TypeError) {
        return true;
      }
    }, 'invalid bad ssl options test (' + i + '): ' + testData[i]);
  }
  test.done();
  fs.rmdirSync('dirCertificate');
};


/**
 * Test that the ssl options for valid certificates cause start to be
 * successful
 * @param {object} test - test case.
 */
module.exports.test_valid_ssl_options = function(test) {
  var testData = [{sslTrustCertificate:'ValidCertificate', sslVerifyName:true},
                  {sslTrustCertificate:'ValidCertificate', sslVerifyName:true},
                  {sslTrustCertificate:'BadVerify', sslVerifyName: false}];
  var validCertificateFd = fs.openSync('ValidCertificate', 'w');
  var badVerifyFd = fs.openSync('BadVerify', 'w');
  var count = 0;
  var validSSLTest = function(sslTrustCertificate, sslVerifyName) {
    var opts = {
      service: 'amqp://host',
      sslTrustCertificate : testData[count].sslTrustCertificate,
      sslVerifyName : testData[count].sslVerifyName,
      id: 'testid'
    };
    var client = mqlight.createClient(opts);
    client.on('error', function(err) {
      client.stop();
      test.ok(!err,'unexpected error event: '+err);
      test.done();
      fs.close(validCertificateFd); fs.unlinkSync('ValidCertificate');
      fs.close(badVerifyFd); fs.unlinkSync('BadVerify');
    });
    client.start(function(err) {
      test.ok(!err);
      client.stop();
      ++count;
      if (count == testData.length) {
        test.done();
        fs.close(validCertificateFd); fs.unlinkSync('ValidCertificate');
        fs.close(badVerifyFd); fs.unlinkSync('BadVerify');
      } else {
        validSSLTest(testData[count].sslTrustCertificate,
            testData[count].sslVerifyName);
      }
    });
  };

  validSSLTest(testData[count].sslTrustCertificate,
      testData[count].sslVerifyName);
};


/**
 * Test that the ssl options for invalid certificates cause start to fail
 * @param {object} test - test case.
 */
module.exports.test_invalid_ssl_options = function(test) {
  var testData = [{sslTrustCertificate:'BadCertificate', sslVerifyName:true},
                  {sslTrustCertificate:'BadCertificate', sslVerifyName:false},
                  {sslTrustCertificate:'BadVerify', sslVerifyName: true}];
  var badCertificateFd = fs.openSync('BadCertificate', 'w');
  var badVerifyFd = fs.openSync('BadVerify', 'w');
  var count = 0;
  var validSSLTest = function(sslTrustCertificate, sslVerifyName) {
    var opts = {
      service: 'amqp://host',
      sslTrustCertificate : testData[count].sslTrustCertificate,
      sslVerifyName : testData[count].sslVerifyName,
      id: 'testid'
    };
    var client = mqlight.createClient(opts);
    client.on('error', function(err) {
      test.ok(err);
      client.stop();
      ++count;
      if (count == testData.length) {
        test.done();
        fs.close(badCertificateFd); fs.unlinkSync('BadCertificate');
        fs.close(badVerifyFd); fs.unlinkSync('BadVerify');
      } else {
        validSSLTest(testData[count].sslTrustCertificate,
            testData[count].sslVerifyName);
      }
    });
    client.on('started', function(err) {
      client.stop();
      test.ok(!err,'unexpected started event');
      test.done();
      fs.close(badCertificateFd); fs.unlinkSync('BadCertificate');
      fs.close(badVerifyFd); fs.unlinkSync('BadVerify');
    });
    client.start();
  };

  validSSLTest(testData[count].sslTrustCertificate,
      testData[count].sslVerifyName);
};
